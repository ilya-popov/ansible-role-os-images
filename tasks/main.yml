---
# qemu-img is required when building qcow images, or extracting cloud images in
# qcow format.
- name: Ensure qemu-img is installed
  yum:
    name: qemu-img
    state: installed
  become: True

# The rpm-distro element executes 'semanage' during its cleanup phase.
- name: Ensure diskimage-builder SELinux dependencies are installed
  yum:
    name: policycoreutils-python
    state: installed
  when:
    - ansible_selinux != False
    - "ansible_selinux.status != 'disabled'"
  become: True

- name: Set up openstack cli virtualenv
  pip:
    virtualenv: "{{ os_images_venv }}"
    name:
      - python-openstackclient
      - python-glanceclient

- name: Ensure download cache dir exists
  file:
    path: "{{ os_images_cache }}"
    state: directory

- name: Remove old images for force rebuild
  file:
    path: "{{ os_images_cache }}/{{ item.name }}"
    state: absent
  when: item.force_rebuild | default(os_images_force_rebuild) | bool
  with_items: "{{ os_images_list }}"
  tags: clean

- name: Generate per-image cache directories
  file:
    path: "{{ os_images_cache }}/{{ item.name }}"
    state: directory
  with_items: "{{ os_images_list }}"

- name: Download the image to the directory when an image_url is defined
  get_url:
    url: "{{ item.image_url }}"
    dest: "{{ os_images_cache }}/{{ item.name }}/{{ item.name }}.{{ item.type | default('qcow2') }}"
  with_items: "{{ os_images_list }}"
  when: item.image_url is defined

- name: Install a suitable version of diskimage-builder
  pip:
    name: "{{ item.name }}"
    version: "{{ item.version or omit }}"
    state: present
    virtualenv: "{{ os_images_venv }}"
  with_items:
    - name: diskimage-builder
      version: "{{ os_images_dib_version }}"

- name: Git clone any additional image element repos
  git:
    repo: "{{ item.repo }}"
    dest: "{{ item.local }}"
    version: "{{ item.version | default('HEAD') }}"
  with_items: "{{ os_images_git_elements }}"

- name: Set a fact containing paths to DIB elements
  set_fact:
    os_images_elements_path: "{{ os_images_elements }}"

- name: Incorporate git-sourced DIB elements
  set_fact:
    os_images_elements_path: >
      {{ os_images_elements_path +
         [item.local ~ '/' ~ item.elements_path] }}
  with_items: "{{ os_images_git_elements }}"
  when: item.elements_path is defined

- name: Set a fact containing the default DIB environment
  set_fact:
    os_image_dib_env_default:
      ELEMENTS_PATH: "{{ os_images_elements_path | join(':') }}"

- name: Generate diskimage-builder images
  command: >
    {{ os_images_venv }}/bin/disk-image-create
      {% if item.size is defined %}--image-size {{ item.size }}{% endif %}
      {% if item.type is defined %}-t {{ item.type }}{% endif %}
      {{ os_images_common }}
      {{ item.elements | join( ' ' ) }} -o {{ item.name }}
  args:
    chdir: "{{ os_images_cache }}/{{ item.name }}"
    creates: "{{ os_images_cache }}/{{ item.name }}/{{ item.name }}.d/dib-manifests"
  environment: "{{ os_image_dib_env_default | combine(item.env | default({})) }}"
  with_items: "{{ os_images_list }}"
  failed_when: false
  register: result
  # The output of this command can be quite large, and is not very useful as
  # a JSON blob.
  when: item.elements is defined
  no_log: true

- name: Ensure DIB build logs are copied if the image failed to build
  copy:
    content: "{{ item.0[item.1] }}"
    dest: "{{ os_images_cache }}/{{ item.0.item.name }}/{{ item.0.item.name }}.{{ item.1 }}"
  with_nested:
    - "{{ result.results }}"
    - [stdout, stderr]
  when:
    - not item.0|skipped
    - item.0.rc != 0
    - item.1 in item.0
  # The output of this command can be quite large, and is not very useful as
  # a JSON blob.
  no_log: true

- name: Fail if any images failed to build
  fail:
    msg: >
      Image {{ item.0.name }} failed to build. See
      {{ item.0.name }}.stdout and {{ item.0.name }}.stderr in
      {{ os_images_cache }}/{{ item.0.name }}.
  when:
    - item.0.elements is defined
    - item.1 != 0
  # Avoid iterating over the results directly as the output can be large, and
  # adding no_log will suppress the failure message.
  with_together:
    - "{{ os_images_list }}"
    - "{{ result.results | map(attribute='rc') | list }}"

- block:
    - name: Set a fact about the current python interpreter
      set_fact:
        old_ansible_python_interpreter: "{{ ansible_python_interpreter | default('/usr/bin/python') }}"

    - name: Ensure Ansible uses virtualenv python interpreter
      set_fact:
        ansible_python_interpreter: "{{ os_images_venv }}/bin/python"

    # with ansible >= 2.5 we could use os_image_facts without an image name
    - name: Gather facts about cloud tenant kernel images
      os_image_facts:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        image: "{{ item.name ~ '-kernel' }}"
      with_items: "{{ os_images_list }}"
      register: kernel_facts
      when:
        - item.elements is defined 
        - '"baremetal" in item.elements'
      
    - name: Compute the MD5 checksum of the kernel images
      stat:
        path: "{{ os_images_cache }}/{{ item.name }}/{{ item.name }}.vmlinuz"
        get_checksum: True
        checksum_algorithm: md5
        mime: False
      with_items: "{{ os_images_list }}"
      register: kernel_checksums
      when:
        - item.elements is defined 
        - '"baremetal" in item.elements'
      
    # with ansible >= 2.5 we could use os_image_facts without an image name
    - name: Gather facts about cloud tenant ramdisk images
      os_image_facts:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        image: "{{ item.name ~ '-ramdisk' }}"
      with_items: "{{ os_images_list }}"
      register: ramdisk_facts
      when:
        - item.elements is defined 
        - '"baremetal" in item.elements'
      
    - name: Compute the MD5 checksum of the ramdisk images
      stat:
        path: "{{ os_images_cache }}/{{ item.name }}/{{ item.name }}.initrd"
        get_checksum: True
        checksum_algorithm: md5
        mime: False
      with_items: "{{ os_images_list }}"
      register: ramdisk_checksums
      when:
        - item.elements is defined 
        - '"baremetal" in item.elements'

    # with ansible >= 2.5 we could use os_image_facts without an image name
    - name: Gather facts about cloud tenant images
      os_image_facts:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        image: "{{ item.name }}"
      with_items: "{{ os_images_list }}"
      register: image_facts

    - name: Compute the MD5 checksum of the images
      stat:
        path: "{{ os_images_cache }}/{{ item.name }}/{{ item.name }}.{{ item.type | default('qcow2') }}"
        get_checksum: True
        checksum_algorithm: md5
        mime: False
      with_items: "{{ os_images_list }}"
      register: image_checksums

    - name: Set fact containing local checksums
      vars:
        query: "[*].stat.{key: path , value: checksum}"
        results: >
          {{ (kernel_checksums.results | default([]) + ramdisk_checksums.results | default([]) +
          image_checksums.results | default([])) }}
      set_fact:
        local_checksums: "{{ local_checksums | default({}) | combine({item.key | basename : item.value | basename })}}"
      with_items: "{{ results | json_query(query) }}"
      
    - name: Set fact containing glance metadata
      vars:
        query: "[*].ansible_facts.openstack_image.{key: name, checksum: checksum, ctime: ctime}"
        results: >
          {{ (kernel_facts.results | default([]) + ramdisk_facts.results | default([]) +
          image_facts.results | default([])) }}
      set_fact:
        glance_metadata: >
          {{ glance_metadata | default({}) | combine({item.key: {'checksum': item.checksum,
          'timestamp': '%Y-%m-%d-%H-%M-%S' | strftime(item.ctime) }}) }}
      with_items: "{{ results | json_query(query) }}"

    - name: Ensure existing cloud tenant kernel does not exist
      vars:
        image_key: "{{ item.name ~ '-kernel' }}"
      os_image:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        name: "{{ item.name ~ '-kernel' }}"
        state: absent
      with_items:
        - "{{ os_images_list }}"
      when:
        - item.elements is defined 
        - '"baremetal" in item.elements'
        - item.force_rebuild | default(os_images_force_rebuild) | bool
        - os_images_overwrite_policy == "overwrite"
        - image_key in glance_metadata
        - glance_metadata[image_key]["checksum"] != local_checksums[item.name ~ '.vmlinuz']
      tags: clean

    - name: Rename old kernel
      vars:
        image_key: "{{ item.name }}-kernel"
        appendix: "-{{ glance_metadata[image_key].timestamp }}"
      command: >
        {{ os_images_venv }}/bin/openstack image set {{ image_key }} --property name={{ image_key ~ appendix}}  
      environment: "{{ openstack_auth_env }}"
      with_items: "{{ os_images_list }}"
      changed_when: False
      when:
        - item.force_rebuild | default(os_images_force_rebuild) | bool
        - os_images_overwrite_policy == "rename"
        - image_key in glance_metadata
        - glance_metadata[image_key]["checksum"] != local_checksums[item.name ~ ".vmlinuz"]

    - name: Upload cloud tenant kernel for baremetal images
      os_image:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        name: "{{ item.name ~ '-kernel' }}"
        state: present
        is_public: yes
        container_format: aki
        disk_format: aki
        filename: "{{ os_images_cache }}/{{ item.name }}/{{ item.name }}.vmlinuz"
      with_items: "{{ os_images_list }}"
      when:
        - item.elements is defined 
        - '"baremetal" in item.elements'
      register: kernel_result

    - name: Rename old ramdisk
      vars:
        image_key: "{{ item.name }}-ramdisk"
        appendix: "-{{ glance_metadata[image_key].timestamp }}"
      command: >
        {{ os_images_venv }}/bin/openstack image set {{ image_key }} --property name={{ image_key ~ appendix}}  
      environment: "{{ openstack_auth_env }}"
      with_items: "{{ os_images_list }}"
      changed_when: False
      when:
        - item.force_rebuild | default(os_images_force_rebuild) | bool
        - os_images_overwrite_policy == "rename"
        - image_key in glance_metadata
        - glance_metadata[image_key]["checksum"] != local_checksums[item.name ~ ".initrd"]

    - name: Ensure existing cloud tenant ramdisk does not exist
      vars:
        image_key: "{{ item.name ~ '-ramdisk' }}"
      os_image:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        name: "{{ image_key }}"
        state: absent
      with_items: "{{ os_images_list }}"
      when:
        - item.elements is defined 
        - '"baremetal" in item.elements'
        - item.force_rebuild | default(os_images_force_rebuild) | bool
        - os_images_overwrite_policy == "overwrite"
        - image_key in glance_metadata
        - glance_metadata[image_key]["checksum"] != local_checksums[item.name ~ '.initrd']
      tags: clean

    - name: Upload cloud tenant ramdisk for baremetal images
      os_image:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        name: "{{ item.name ~ '-ramdisk' }}"
        state: present
        is_public: yes
        container_format: ari
        disk_format: ari
        filename: "{{ os_images_cache }}/{{ item.name }}/{{ item.name }}.initrd"
      with_items: "{{ os_images_list }}"
      when:
        - item.elements is defined 
        - '"baremetal" in item.elements'

      register: ramdisk_result

    - name: Ensure existing cloud tenant image does not exist
      vars:
        file_extension: ".{{ item.type | default('qcow2') }}"
        image_key: "{{ item.name }}"
      os_image:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        name: "{{ item.name }}"
        state: absent
      with_items: "{{ os_images_list }}"
      when:
        - item.force_rebuild | default(os_images_force_rebuild) | bool
        - os_images_overwrite_policy == "overwrite"
        - image_key in glance_metadata
        - glance_metadata[image_key]["checksum"] != local_checksums[item.name ~ file_extension]
      tags: clean

    - name: Rename old image
      vars:
        image_key: "{{ item.name }}"
        file_extension: ".{{ item.type | default('qcow2') }}"
        appendix: "-{{ glance_metadata[item.name].timestamp }}"
      command: >
        {{ os_images_venv }}/bin/openstack image set {{ item.name }} --property name={{ item.name ~ appendix}}  
      environment: "{{ openstack_auth_env }}"
      with_items: "{{ os_images_list }}"
      changed_when: False
      when:
        - item.force_rebuild | default(os_images_force_rebuild) | bool
        - os_images_overwrite_policy == "rename"
        - image_key in glance_metadata
        - glance_metadata[image_key]["checksum"] != local_checksums[item.name ~ file_extension]

    - name: Upload cloud tenant images
      os_image:
        auth_type: "{{ os_images_auth_type }}"
        auth: "{{ os_images_auth }}"
        name: "{{ item.0.name }}"
        state: present
        is_public: yes
        container_format: bare
        disk_format: "{{ item.type | default('qcow2') }}"
        filename: "{{ os_images_cache }}/{{ item.0.name }}/{{ item.0.name }}.{{ item.type | default('qcow2') }}"
        properties: "{{ os_images_common_properties | combine(item.0.properties | default({})) or omit }}"
        kernel: "{{ item.1.id if is_baremetal else omit }}"
        ramdisk: "{{ item.2.id if is_baremetal else omit }}"
      vars:
        is_baremetal: "{{ item.0.elements is defined and 'baremetal' in item.0.elements }}"
      with_together:
        - "{{ os_images_list }}"
        - "{{ kernel_result.results }}"
        - "{{ ramdisk_result.results }}"

    # This variable is unset before we set it, and it does not appear to be
    # possible to unset a variable in Ansible.
    - name: Set a fact to reset the Ansible python interpreter
      set_fact:
        ansible_python_interpreter: "{{ old_ansible_python_interpreter }}"

  when: os_images_upload | bool
